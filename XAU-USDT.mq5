//+------------------------------------------------------------------+
//|                  XAUUSD-EA-5M-Sync.mq5                            |
//|        Fully synced with XAUUSDbot.py (Python signal bot)        |
//|                   Works with $100 account                        |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025"
#property version   "1.10"
#property strict
#property description "XAUUSD 5M EA - Syncs with Python bot via JSON + standalone mode"

#include <Trade\Trade.mqh>
CTrade trade;

//+------------------------------------------------------------------+
// Input Parameters
input string          _________SETTINGS_________ = "=== TRADING SETTINGS ===";
input double          RiskPercent         = 1.5;        // Risk per trade (%)
input double          EntryBufferPct      = 0.20;       // Trail activation buffer (%)
input double          MinScore            = 65.0;       // Min score to trade
input int             Leverage             = 20;
input string          SymbolName          = "XAUUSD";
input ulong           MagicNumber         = 20251122;
input bool            UseJsonSignal       = true;       // Read from latest_xau_signal.json
input string          JsonFileName        = "latest_xau_signal.json";

input string          _________TIMEFRAMES_________ = "=== TIMEFRAMES ===";
input ENUM_TIMEFRAMES MainTF              = PERIOD_M5;
input bool            UseM3Confirm        = true;
input bool            UseM1Confirm        = true;

//+------------------------------------------------------------------+
// Global variables
string   signal_side     = "";
double   signal_entry    = 0;
double   signal_tp       = 0;
double   signal_sl       = 0;
double   signal_trail    = 0;
double   signal_qty      = 0;
double   signal_score    = 0;
datetime last_trade_time = 0;

//+------------------------------------------------------------------+
// OnInit
int OnInit()
{
   if(!SymbolSelect(SymbolName, true))
   {
      Print("Symbol ", SymbolName, " not found!");
      return INIT_FAILED;
   }
   trade.SetExpertMagicNumber(MagicNumber);
   Print("XAUUSD 5M EA Started | Risk: ", RiskPercent, "% | Use JSON: ", UseJsonSignal);
   return INIT_SUCCEEDED;
}

//+------------------------------------------------------------------+
// Read signal from JSON file (generated by Python bot)
bool ReadJsonSignal()
{
   if(!UseJsonSignal) return false;

   int file_handle = FileOpen(JsonFileName, FILE_READ|FILE_TXT);
   if(file_handle == INVALID_HANDLE) return false;

   string json = FileReadString(file_handle);
   FileClose(file_handle);

   if(StringFind(json, "Side") == -1) return false;

   signal_side   = StringSubstr(json, StringFind(json, "\"Side\": \"") + 9, 4);
   if(signal_side != "LONG" && signal_side != "SHOR") return false;

   signal_entry  = StringToDouble(StringSubstr(json, StringFind(json, "\"Entry\": ") + 9, 10));
   signal_tp     = StringToDouble(StringSubstr(json, StringFind(json, "\"TP\": ") + 7, 10));
   signal_sl     = StringToDouble(StringSubstr(json, StringFind(json, "\"SL\": ") + 7, 10));
   signal_trail  = StringToDouble(StringSubstr(json, StringFind(json, "\"Trail\": ") + 10, 10));
   signal_qty    = StringToDouble(StringSubstr(json, StringFind(json, "\"Qty\": ") + 8, 6));
   signal_score  = StringToDouble(StringSubstr(json, StringFind(json, "\"Score\": ") + 10, 5));

   if(signal_score < MinScore) return false;

   PrintFormat("JSON Signal Loaded | %s | Score: %.1f%% | Entry: %.2f", 
               signal_side=="LONG"?"BUY":"SELL", signal_score, signal_entry);
   return true;
}

//+------------------------------------------------------------------+
// Calculate lot size based on risk %
double CalculateLotSize(double entry, double sl)
{
   double risk_amount = AccountInfoDouble(ACCOUNT_BALANCE) * RiskPercent / 100.0;
   double sl_distance = MathAbs(entry - sl);
   if(sl_distance < 0.01) return 0.01;

   double tick_value = SymbolInfoDouble(SymbolName, SYMBOL_TRADE_TICK_VALUE);
   double tick_size  = SymbolInfoDouble(SymbolName, SYMBOL_TRADE_TICK_SIZE);
   double point      = SymbolInfoDouble(SymbolName, SYMBOL_POINT);
   double value_per_point = tick_value / tick_size * point;

   double lots = risk_amount / (sl_distance / point * value_per_point);
   lots = NormalizeDouble(lots, 2);

   double min_lot = SymbolInfoDouble(SymbolName, SYMBOL_VOLUME_MIN);
   double max_lot = SymbolInfoDouble(SymbolName, SYMBOL_VOLUME_MAX);
   double lot_step = SymbolInfoDouble(SymbolName, SYMBOL_VOLUME_STEP);

   lots = MathMax(min_lot, MathMin(lots, max_lot));
   lots = lot_step * MathFloor(lots / lot_step);

   return MathMax(lots, min_lot);
}

//+------------------------------------------------------------------+
// Check if we already have a position
bool HasOpenPosition()
{
   for(int i = 0; i < PositionsTotal(); i++)
   {
      if(PositionGetSymbol(i) == SymbolName && PositionGetInteger(POSITION_MAGIC) == MagicNumber)
         return true;
   }
   return false;
}

//+------------------------------------------------------------------+
// Open Trade
void OpenTradeFromSignal()
{
   if(HasOpenPosition()) return;
   if(signal_side != "LONG" && signal_side != "SHOR") return;

   bool is_buy = (signal_side == "LONG");
   double price = is_buy ? SymbolInfoDouble(SymbolName, SYMBOL_ASK) 
                         : SymbolInfoDouble(SymbolName, SYMBOL_BID);

   double sl = signal_sl;
   double tp = signal_tp;
   double lots = signal_qty > 0 ? signal_qty : CalculateLotSize(signal_entry, sl);

   if(lots < 0.01)
   {
      Print("Lot size too small: ", lots);
      return;
   }

   bool result = false;
   if(is_buy)
      result = trade.Buy(lots, SymbolName, 0, sl, tp, "XAU Bot Sync");
   else
      result = trade.Sell(lots, SymbolName, 0, sl, tp, "XAU Bot Sync");

   if(result)
   {
      PrintFormat("TRADE OPENED | %s | Lots: %.2f | Entry: %.2f | TP: %.2f | SL: %.2f | Score: %.1f%%",
                  is_buy?"BUY":"SELL", lots, price, tp, sl, signal_score);
      last_trade_time = TimeCurrent();
   }
   else
      Print("Trade failed: ", trade.ResultRetcodeDescription());
}

//+------------------------------------------------------------------+
// Trailing Stop Logic (activates after buffer)
void TrailingStop()
{
   double buffer = EntryBufferPct / 100.0;
   for(int i = 0; i < PositionsTotal(); i++)
   {
      if(PositionGetSymbol(i) != SymbolName || PositionGetInteger(POSITION_MAGIC) != MagicNumber)
         continue;

      ulong ticket = PositionGetTicket(i);
      double open_price = PositionGetDouble(POSITION_PRICE_OPEN);
      double sl = PositionGetDouble(POSITION_SL);
      double tp = PositionGetDouble(POSITION_TP);
      double current_price = PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY ?
                             SymbolInfoDouble(SymbolName, SYMBOL_BID) :
                             SymbolInfoDouble(SymbolName, SYMBOL_ASK);

      double trail_level = PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY ?
                           open_price * (1 + buffer) : open_price * (1 - buffer);

      if((PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY && current_price > trail_level) ||
         (PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_SELL && current_price < trail_level))
      {
         double new_sl = PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY ?
                         trail_level : trail_level;

         if((PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY && new_sl > sl) ||
            (PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_SELL && new_sl < sl))
         {
            trade.PositionModify(ticket, new_sl, tp);
         }
      }
   }
}

//+------------------------------------------------------------------+
// OnTick
void OnTick()
{
   static datetime last_check = 0;
   datetime now = TimeCurrent();

   // Run every new 5M candle
   if(now - last_check < 300) return;  // 5 minutes
   if(TimeMinute(now) % 5 != 0 && (TimeMinute(now)-1) % 5 != 0) return;

   last_check = now;

   // Reset signal
   signal_side = "";

   // 1. Try to read from JSON (from Python bot)
   if(ReadJsonSignal())
   {
      if(!HasOpenPosition() && signal_score >= MinScore)
         OpenTradeFromSignal();
   }
   else if(!UseJsonSignal)
   {
      // 2. Fallback: simple standalone logic (same as Python)
      // You can expand this later if needed
      Print("No JSON signal - standalone mode active (not implemented yet)");
   }

   TrailingStop();
}

//+------------------------------------------------------------------+